<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <title>Administrator View</title>
        <meta name="viewport" content="initial-scale=1">
        <link rel="stylesheet" href="css/d3.slider.css" />  

        <style>
            .node {
                cursor: move;
            }

            .node text {
                pointer-events: none;
                font-family: sans-serif;
                font-size: 12px;
            }

            .node rect {
                pointer-events: none;
                stroke: black;
                stroke-width: 4px;
            }

            .link {
                stroke: #999;
                stroke-width: 1.5px;
            }

            .floatTL {
                position: fixed;
                top: 0px;
                left: 0px;
            }
        </style>
    </head>
    <body>
        <div style="width:100%" class="floatTL">
            Scale: <span id="zoomValue">50</span>
            <div id ="zoomSlider" style="width:20%"></div>
        </div>


        <script src="http://d3js.org/d3.v3.min.js"></script>
        <script src="js/d3.slider.js"></script>

        <script>
            adminView = function() {
                /** Namespace prefix constants **/
                var RDFS_PREFIX = 'http://www.w3.org/2000/01/rdf-schema#';
                var RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
                var XSD_PREFIX = 'http://www.w3.org/2001/XMLSchema#';
                var OWL_PREFIX = 'http://www.w3.org/2002/07/owl#';
                var NML_PREFIX = 'http://schemas.ogf.org/nml/2013/03/base#';
                var MRS_PREFIX = 'http://schemas.ogf.org/mrs/2013/12/topology#';

                /** Document and canvas sizes **/
                var width = document.documentElement.clientWidth;
                var height = document.documentElement.clientHeight;
                var canvasWidth = width * 2;
                var canvasHeight = height * 2;
                var svg, drag, force;

                var nodesDictionary = [];
                var linksList = [];
                var nodesList = [];
                var topologyList = [];
                var node = [];
                var link = [];

                var owns = Object.prototype.hasOwnProperty;

                var css = {
                    classes: {
                        nodeText: '.node text',
                        nodeImage: '.node image',
                        link: '.link'
                    },
                    IDs: {
                        zoomSlider: '#zoomSlider',
                        zoomValue: '#zoomValue'
                    }
                };

                var settings = {
                    /** 
                     * Zoom takes on values in the range [0, 100].
                     * The base zoom value defines 1x zoom.
                     * Any other zoom value causes a scaling equal to a
                     * percentage of the base zoom value. 
                     **/
                    baseZoomValue: 50,
                    /** Font size in px **/
                    baseFontSize: 12,
                    /** Resource paths **/
                    baseIconPath: 'resources/',
                    defaultIcon: 'default.png',
                    defaultGraphPath: 'data/graph-full.json',
                    /** Icon image size **/
                    iconWidth: 30,
                    iconHeight: 30,
                    /** Node text offsets **/
//                    nodeTextOffsetX: 30,
//                    nodeTextOffsetY: 15,
                    /** Topology panel attributes **/
                    topologyPanelWidth: 370,
                    topologyPanelHeight: 50,
                    topologyPanelBorderRounding: 5,
                    /** Force graph fundamental values **/
                    baseCharge: -10, // node-node force strength
                    baseGravity: 80, // node-center force strength
                    baseDistance: 75 // distance between linked nodes
                };

                var nodeTypes = {
                    typeNames: {
                        topology: NML_PREFIX + 'Topology',
                        bidirectionalPort: NML_PREFIX + 'BidirectionalPort',
                        storageService: MRS_PREFIX + 'StorageService',
                        node: NML_PREFIX + 'Node',
                        blockStorageService: MRS_PREFIX + 'BlockStorageService',
                        route: MRS_PREFIX + 'Route',
                        hypervisorBypassInterfaceService: MRS_PREFIX + 'HypervisorBypassInterfaceService',
                        switchingService: NML_PREFIX + 'SwitchingService',
                        virtualSwitchService: MRS_PREFIX + 'VirtualSwitchService',
                        routingService: MRS_PREFIX + 'RoutingService',
                        ioPerformanceMeasurementService: MRS_PREFIX + 'IOPerformanceMeasurementService',
                        posixIOBenchmark: MRS_PREFIX + 'POSIX_IOBenchmark',
                        hypervisorService: MRS_PREFIX + 'HypervisorService',
                        address: MRS_PREFIX + 'Address'
                    },
                    iconNames: {
                        topology: 'topology.jpg',
                        bidirectionalPort: 'bidirectional_port.jpg',
                        storageService: 'storage_service.jpg',
                        node: 'node.jpg',
                        blockStorageService: 'block_storage_service.jpg',
                        route: 'route.jpg',
                        hypervisorBypassInterfaceService: 'hypervisor_bypass_interface_service.jpg',
                        switchingService: 'switching_service.jpg',
                        virtualSwitchService: 'virtual_switch_service.jpg',
                        routingService: 'routing_service.jpg',
                        ioPerformanceMeasurementService: 'io_perf_service.jpg',
                        posixIOBenchmark: 'io_benchmark.jpg',
                        hypervisorService: 'hypervisor_service.jpg'
                    }
                };

                var properties = {
                    hasNode: NML_PREFIX + 'hasNode',
                    hasService: NML_PREFIX + 'hasService',
                    isAlias: NML_PREFIX + 'isAlias',
                    topology: NML_PREFIX + 'Topology',
                    type: RDF_PREFIX + 'type',
                    labelType: NML_PREFIX + 'labeltype'
                };

                // Module execution starts here
                function main() {
                    createZoomSlider();

                    // Load graph JSON at user specified path and process it
                    var graph = prompt('Enter path to graph JSON file', settings.defaultGraphPath);
                    d3.json(graph, processJSON);
                }

                function processJSON(error, json) {
                    console.log("Processing json...");
                    console.log(json);

                    // Create a lookup dictionary of all nodes
                    populateNodesDictionary(json);

                    // Parse graph JSON into data structures and objects
                    console.log('Generating nodes and links from json...');
                    for (var key in nodesDictionary) {
                        var node = nodesDictionary[key];
                        console.log('Processing node: ', node);
                        if (isTopology(node.jsonObj)) { // store topology objects and relations
                            var children = mergeProperties(node.jsonObj[properties.hasNode], node.jsonObj[properties.hasService]);
                            var childrenNodes = [];

                            for (var key in children) {
                                if (!owns.call(children, key)) {
                                    continue;
                                }

                                var target = findByName(nodesDictionary, removePrefix(children[key].value, 'urn:ogf:network:'));
                                if (target) {
                                    childrenNodes.push(target);
                                }
                            }

                            node.nodes = childrenNodes;
                            node.visible = true;

                            console.log('Adding topology');
                            console.log(node);

                            topologyList.push(node);
                            nodesList.push(node);

                            // Add any topology links
                            for (var key in childrenNodes) {
//                                linksList.push({source: node, target: childrenNodes[key], visible: false});
                            }
                        } else if (shouldBeDisplayed(node.jsonObj)) { // store all other nodes that are displayed
                            node.visible = true;
                            nodesList.push(node);
                        } else { // ignored nodes
                            console.log('Ignored element ' + node.name);
                        }


                        // Add any alias links that exist
                        if (hasProperty(node.jsonObj, properties.isAlias)) {
                            for (var i = 0, l = node.jsonObj[properties.isAlias].length; i < l; ++i) {
                                var target = findByName(nodesDictionary, node.jsonObj[properties.isAlias][i].value);
                                if (target) {
//                                    linksList.push({source: node, target: target, visible: true});
                                }
                            }
                        }
                    }

                    // Hide topology children nodes
                    for (var topology in topologyList) {
                        for (var key in topologyList[topology].nodes) {
                            var node = findByName(nodesList, topologyList[topology].nodes[key].name);
                            if (node) {
                                nodesList.splice(indexOfName(nodesList, node.name), 1);
                            }
                        }
                    }

                    initForceGraph(); // generate the parsed graph
                }

                function populateNodesDictionary(json) {
                    console.log("Creating lookup dictionary...");
                    for (var key in json) {
                        var obj = json[key];
                        var name = removePrefix(key, 'urn:ogf:network:');
                        var iconPath = getIconPath(obj);

                        var node = {name: name, jsonObj: obj, icon: iconPath};
                        nodesDictionary.push(node);
                    }
                }

                /** FUNCTIONALITY **/
                function initForceGraph() {
                    console.log('Initializing force graph');

                    /**
                     * k is porportional to the square root of the graph density
                     * and is used as a heuristic to set appropriate values for the
                     * charge and gravity of the force graph
                     * credit to mbostock on Stack Overflow for the idea
                     */
                    var k = Math.sqrt(nodesList.length / (canvasWidth * canvasHeight));
                    var charge = settings.baseCharge / k;
                    var gravity = settings.baseGravity * k;
                    var distance = settings.baseDistance * (1 + (100 * k));

                    console.log('Calculated k-value ' + k);
                    console.log('Calculated charge ' + charge);
                    console.log('Calculated gravity ' + gravity);
                    console.log('Calculated distance ' + distance);


                    force = d3.layout.force()
                            .size([canvasWidth, canvasHeight])
                            .charge(charge)
                            .gravity(gravity)
                            .linkDistance(distance)
                            .nodes(nodesList)
                            .links(linksList)
                            .on('tick', tick);

                    svg = d3.select('body').append('svg')
                            .attr('width', canvasWidth)
                            .attr('height', canvasHeight);

                    drag = force.drag()
                            .on('drag', ondrag);

                    console.log('Success');

                    restart();
                }

                function restart() {
                    link = svg.selectAll('.link')
                            .data(linksList)
                            .enter().append('line')
                            .attr('class', 'link');

                    node = svg.selectAll('.node')
                            .data(nodesList);

                    console.log(node.enter());
                    console.log(node.exit());

                    // Enter
                    node.enter()
                            .append('g')
                            .attr('class', 'node')
                            .on('dblclick', dblclick)
                            .on('click', click)
                            .call(drag);

                    node.append('rect')
                            .style({'stroke': 'black', 'stroke-width': '4', 'opacity': '0.5', 'fill': randomRGB})
                            .attr('width', settings.topologyPanelWidth)
                            .attr('height', settings.topologyPanelHeight)
                            .attr('x', 0)
                            .attr('y', -settings.topologyPanelHeight / 2 + settings.iconHeight / 2)
                            .attr('rx', settings.topologyPanelBorderRounding)
                            .attr('ry', settings.topologyPanelBorderRounding);

                    node.append('image')
                            .attr('xlink:href', function(d) {
                                return d.icon;
                            })
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', settings.iconWidth)
                            .attr('height', settings.iconHeight);

                    node.append('text')
                            .attr('x', settings.iconWidth)
                            .attr('y', settings.iconHeight / 2)
                            .text(function(d) {
                                return d.name;
                            });

                    // Exit
                    node.exit().remove();

                    force.start();
                }

                /** Slider control for graph zoom level **/
                function createZoomSlider() {
                    d3.select(css.IDs.zoomSlider).call(
                            d3.slider()
                            .value(settings.baseZoomValue)
                            .on('slide', function(evt, value) {
                                d3.select(css.IDs.zoomValue).text(Math.round(value));
                                resize(value);
                            }));
                }

                function resize(size) {
                    var scaling = size / settings.baseZoomValue;
                    svg.selectAll(css.classes.nodeText).style('font-size', settings.baseFontSize * scaling + 'px');
                    svg.selectAll(css.classes.nodeImage).attr('transform', 'scale(' + scaling + ')');
                    svg.selectAll(css.classes.link).style('stroke-width', scaling);
                }

                /** PRIVATE UTILITY FUNCTIONS **/
                function indexOfName(array, search) {
                    for (var i = 0; i < array.length; ++i) {
                        if (array[i].name === search) {
                            return i;
                        }
                    }

                    return -1;
                }

                function findByName(array, name) {
                    var index = indexOfName(array, removePrefix(name, 'urn:ogf:network:'));
                    if (index >= 0) {
                        return array[index];
                    } else {
                        return null;
                    }
                }

                function  mergeProperties(p1, p2) {
                    var p3 = p1 || {};

                    for (var property in p2) {
                        if (owns.call(p2, property)) {
                            p3[property] = p2[property];
                        }
                    }

                    return p3;
                }


                function hasProperty(obj, property) {
                    for (var objProperty in obj) {
                        if (owns.call(obj, objProperty) && objProperty === property) {
                            return true;
                        }
                    }

                    return false;
                }

                function hasType(obj, type) {
                    for (var objType in obj) {
                        var typeValue = obj[objType].value;
                        if (owns.call(obj, objType) && typeValue === type) {
                            return true;
                        }
                    }

                    return false;
                }

                function randomRGB() {
                    return 'rgb(' + randomInt(255) + ',' + randomInt(255) + ',' + randomInt(255) + ')';
                }

                function randomInt(int) {
                    return Math.floor(Math.random() * int);
                }

                function removePrefix(string, prefix) {
                    var regexp = new RegExp(escapeRegExp(prefix), 'ig');
                    return string.replace(regexp, '');
                }

                /**
                 * bobince
                 * stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
                 */
                function escapeRegExp(s) {
                    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                }

                /************************************************************
                 * TypeEnum is created on first call if not already defined.
                 * TypeEnum is a constant static hash such that:
                 * The keys of TypeEnum are fully expanded type names
                 * The values of TypeEnum are corresponding icon paths
                 * 
                 * If TypeEnum holds an icon path for a type it is returned,
                 * otherwise a default icon path is returned.
                 ************************************************************/
                function getIconPath(obj) {
                    if (getIconPath.TypeEnum === undefined) {
                        var types = nodeTypes.typeNames;
                        var icons = nodeTypes.iconNames;
                        getIconPath.TypeEnum = {};

                        for (var key in types) {
                            if (owns.call(types, key)) {
                                getIconPath.TypeEnum[types[key]] = settings.baseIconPath + icons[key];
                            }
                        }

                        Object.freeze(getIconPath.TypeEnum);
                    }

                    if (hasProperty(obj, properties.type)) {
                        for (var key in obj[properties.type]) {
                            var type = obj[properties.type][key].value;
                            var path = getIconPath.TypeEnum[type];

                            if (path) {
                                return path;
                            }
                        }
                    }


                    return settings.baseIconPath + settings.defaultIcon;
                }

                /** 
                 * Display elements from NML or MRS namesapce
                 * Except, do not display labeltypes or addresses
                 */
                function shouldBeDisplayed(obj) {
                    if (hasProperty(obj, properties.labelType)) {
                        return false;
                    } else if (hasProperty(obj, properties.type)) {
                        for (var type in obj[properties.type]) {
                            var typeValue = obj[properties.type][type].value;

                            if (typeValue === MRS_PREFIX + 'Address') {
                                return false;
                            } else if (typeValue.indexOf('http://schemas.ogf.org/') >= 0) {
                                return true;
                            }
                        }
                    }

                    console.log('Could not decide whether to display an object, defaulted to false');
                    return false;
                }

                function getNonTopologyNodes(nodes) {
                    var ret = [];
                    for (var node in nodes) {
                        if (owns.call(nodes, node) && !isTopologyNode(nodes[node])) {
                            ret.push(nodes[node]);
                        }
                    }

                    return ret;
                }

                function isTopologyNode(node) {
                    var topology, key, nodeName, topologyNode;

                    for (key in topologyList) {
                        if (!owns.call(topologyList, key)) {
                            continue;
                        }

                        topology = topologyList[key];
                        for (topologyNode in topology.nodes) {
                            if (!owns.call(topology.nodes, topologyNode)) {
                                continue;
                            }

                            nodeName = topology.nodes[topologyNode].name;
                            if (node.name === nodeName) {
                                return true;
                            }
                        }
                    }

                    return false;
                }

                function isTopology(obj) {
                    if (hasProperty(obj, properties.type)) {
                        if (hasType(obj[properties.type], nodeTypes.typeNames.topology)) {
                            return true;
                        }
                    }

                    return false;
                }

                /** EVENT HANDLER FUNCTIONS **/
                function click(d) {
                    if (d3.event.defaultPrevented) {
                        return; // click suppressed
                    }

                    console.log('Clicked on');
                    console.log(d);

                    var key, node, index;
                    var topology = findByName(topologyList, d.name);
                    if (topology) {
                        for (key in topology.nodes) {
                            if (owns.call(topology.nodes, key)) {
                                node = topology.nodes[key];

                                console.log('Toggle ' + node.name + ' visible:' + !node.visible);
                                node.visible = !node.visible;

                                index = indexOfName(node.name);

                                if (index < 0) {
                                    nodesList.push(node);
                                } else {
//                                    nodesList.splice(index, 1);
                                }
                            }
                        }
                        tick();
                    }
                }

                function dblclick(d) {
                    d3.select(this).classed('fixed', d.fixed = false);
                }

                function ondrag(d) {
                    d3.select(this).classed('fixed', d.fixed = true);
                }

                /** GRAPH UPDATE **/
                function tick() {
                    link = svg.selectAll('.link');
                    link
                            .attr('x1', function(d) {
                                return d.source.x + settings.iconWidth / 2;
                            })
                            .attr('y1', function(d) {
                                return d.source.y + settings.iconHeight / 2;
                            })
                            .attr('x2', function(d) {
                                return d.target.x + settings.iconWidth / 2;
                            })
                            .attr('y2', function(d) {
                                return d.target.y + settings.iconHeight / 2;
                            });
                    link
                            .attr('opacity', function(d) {
                                if (d.visible) {
                                    return 100;
                                } else {
                                    return 0;
                                }
                            });

                    node = svg.selectAll('.node');
                    node.attr('transform', function(d) {
                        return 'translate(' + d.x + ',' + d.y + ')';
                    });
                    node.attr('opacity', function(d) {
                        if (d.visible) {
                            return 100;
                        } else {
                            return 0;
                        }
                    });
                }

                /** PUBLIC INTERFACE **/
                return {
                    main: main,
                    css: css,
                    settings: settings,
                    types: nodeTypes
                };
            }(); // end adminView module

            adminView.main(); // execute adminView module
        </script>
    </body>
</html>
