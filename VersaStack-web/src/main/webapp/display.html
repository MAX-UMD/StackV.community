<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <title>Administrator View</title>
        <meta name="viewport" content="initial-scale=1">
        <link rel="stylesheet" href="css/d3.slider.css" />  

        <style>
            .node {
                cursor: move;
            }

            .node text {
                pointer-events: none;
                font-family: sans-serif;
                font-size: 12px;
            }

            .link {
                stroke: #999;
                stroke-width: 1.5px;
            }

            .floatTL {
                position: fixed;
                top: 0px;
                left: 0px;
            }
        </style>
    </head>
    <body>
        <div style="width:100%" class="floatTL">
            Scale: <span id="zoomValue">50</span>
            <div id ="zoomSlider" style="width:20%"></div>
        </div>


        <script src="http://d3js.org/d3.v3.min.js"></script>
        <script src="js/d3.slider.js"></script>

        <script>
            adminView = function() {
                /** Namespace prefix constants **/
                var RDFS_PREFIX = 'http://www.w3.org/2000/01/rdf-schema#';
                var RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
                var XSD_PREFIX = 'http://www.w3.org/2001/XMLSchema#';
                var OWL_PREFIX = 'http://www.w3.org/2002/07/owl#';
                var NML_PREFIX = 'http://schemas.ogf.org/nml/2013/03/base#';
                var MRS_PREFIX = 'http://schemas.ogf.org/mrs/2013/12/topology#';

                /** Document and canvas sizes **/
                var width = document.documentElement.clientWidth;
                var height = document.documentElement.clientHeight;
                var canvasWidth = width * 2;
                var canvasHeight = height * 2;

                var nodesList = [];
                var linksList = [];
                var topologyList = [];
                var node = [];
                var link = [];

                var svg = d3.select('body').append('svg')
                        .attr('width', canvasWidth)
                        .attr('height', canvasHeight);

                var css = {
                    classes: {
                        nodeText: '.node text',
                        nodeImage: '.node image',
                        link: '.link'
                    },
                    IDs: {
                        zoomSlider: '#zoomSlider',
                        zoomValue: '#zoomValue'
                    }
                };

                var settings = {
                    /** 
                     * Zoom takes on values in the range [0, 100].
                     * The base zoom value defines 1x zoom.
                     * Any other zoom value causes a scaling equal to a
                     * percentage of the base zoom value. 
                     **/
                    baseZoomValue: 50,
                    /** Font size in px **/
                    baseFontSize: 12,
                    /** Resource paths **/
                    baseIconPath: 'resources/',
                    defaultIcon: 'default.png',
                    defaultGraphPath: 'data/graph-full.json',
                    /** Icon image size in px **/
                    iconWidth: 30,
                    iconHeight: 30,
                    /** Node text offsets **/
                    nodeTextOffsetX: 15,
                    nodeTextOffsetY: '.35em',
                    /** Force graph fundamental values **/
                    baseCharge: -20, // node-node force strength
                    baseGravity: 80, // node-center force strength
                    baseDistance: 75 // distance between linked nodes
                };

                var nodeTypes = {
                    typeNames: [
                        NML_PREFIX + 'Topology',
                        NML_PREFIX + 'BidirectionalPort',
                        MRS_PREFIX + 'StorageService',
                        NML_PREFIX + 'Node',
                        MRS_PREFIX + 'BlockStorageService',
                        MRS_PREFIX + 'Route',
                        MRS_PREFIX + 'HypervisorBypassInterfaceService',
                        NML_PREFIX + 'SwitchingService',
                        MRS_PREFIX + 'VirtualSwitchService',
                        MRS_PREFIX + 'RoutingService',
                        MRS_PREFIX + 'IOPerformanceMeasurementService',
                        MRS_PREFIX + 'POSIX_IOBenchmark',
                        MRS_PREFIX + 'HypervisorService'
                    ],
                    iconNames: [
                        'topology.jpg',
                        'bidirectional_port.jpg',
                        'storage_service.jpg',
                        'node.jpg',
                        'block_storage_service.jpg',
                        'route.jpg',
                        'hypervisor_bypass_interface_service.jpg',
                        'switching_service.jpg',
                        'virtual_switch_service.jpg',
                        'routing_service.jpg',
                        'io_perf_service.jpg',
                        'io_benchmark.jpg',
                        'hypervisor_service.jpg'
                    ]
                };

                function main() {
                    createZoomSlider();

                    // Load graph JSON at user specified path and process it
                    var graph = prompt('Enter path to graph JSON file', settings.defaultGraphPath);
                    d3.json(graph, processJSON);
                }

                // Parse graph JSON into data structures and objects
                function processJSON(error, json) {
                    console.log('Generating node and link lists from json');
                    console.log(json);

                    for (var obj in json) {
                        var display = (function() { // whether to show obj on graph
                            for (var property in json[obj]) {
                                /** 
                                 * Display elements from NML or MRS namesapce
                                 * Except, do not display labeltypes or addresses
                                 */
                                if (property === NML_PREFIX + 'labeltype') {
                                    console.log('Ignored labelgroup ' + obj);
                                    return false;
                                } else if (property === RDF_PREFIX + 'type') {
                                    for (var type in json[obj][property]) {
                                        var typeValue = json[obj][property][type].value;

                                        if (typeValue === MRS_PREFIX + 'Address') {
                                            console.log('Ignored address ' + obj);
                                            return false;
                                        } else if (typeValue.indexOf('http://schemas.ogf.org/') >= 0) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        })();

                        if (display) { // add new node
                            var iconPath = getIconPath(json[obj]); // find icon based on type
                            var source = {name: obj, icon: iconPath, visible: true};
                            nodesList.push(source);
                        }
                    }

                    for (var obj in json) {
                        // Store topology objects and relations
                        if (obj.indexOf('topology') >= 0) {
                            for (var property in json[obj]) {
                                if (property === NML_PREFIX + 'hasNode' || property === NML_PREFIX + 'hasService') {
                                    var topology = {name: obj, nodes: json[obj][property]};
                                    console.log('Adding topology');
                                    console.log(topology);
                                    topologyList.push(topology);
                                    for (var node in json[obj][property]) {
                                        var index = indexOfName(nodesList, json[obj][property][node].value);
                                        var sourceIndex = indexOfName(nodesList, obj);
                                        if (index >= 0 && sourceIndex >= 0) {
                                            linksList.push({source: nodesList[sourceIndex], target: nodesList[index], visible: false});
                                        }
                                    }
                                }
                            }
                        }

                        // Add any alias links that exist
                        for (var property in json[obj]) {
                            if (property === NML_PREFIX + 'isAlias') {
                                for (var i = 0; i < json[obj][property].length; ++i) {
                                    var index = indexOfName(nodesList, json[obj][property][i].value);
                                    var sourceIndex = indexOfName(nodesList, obj);
                                    if (index >= 0 && sourceIndex >= 0) {
                                        linksList.push({source: nodesList[sourceIndex], target: nodesList[index], visible: true});
                                    }
                                }
                            }
                        }
                    }


                    // Hide topology nodes by default
                    for (var topology in topologyList) {
                        for (var key in topologyList[topology].nodes) {
                            var node = findByName(nodesList, topologyList[topology].nodes[key].value);
                            if (node) {
                                node.visible = false;
                            }
                        }
                    }

                    console.log('Initializing force graph');

                    /**
                     * k is porportional to the square root of the graph density
                     * and is used as a heuristic to set appropriate values for the
                     * charge and gravity of the force graph
                     * credit to mbostock on Stack Overflow for the idea
                     */
                    var k = Math.sqrt(nodesList.length / (width * height));
                    var charge = settings.baseCharge / k;
                    var gravity = settings.baseGravity * k;
                    var distance = settings.baseDistance * (1 + 10 * k);

                    console.log('Calculated k-value ' + k);
                    console.log('Calculated charge ' + charge);
                    console.log('Calculated gravity ' + gravity);
                    console.log('Calculated distance ' + distance);


                    var force = d3.layout.force()
                            .size([canvasWidth, canvasHeight])
                            .charge(charge)
                            .gravity(gravity)
                            .linkDistance(distance)
                            .on('tick', tick)
                            .nodes(nodesList)
                            .links(linksList)
                            .start();

                    var drag = force.drag()
                            .on('drag', ondrag);

                    link = svg.selectAll('.link')
                            .data(linksList)
                            .enter().append('line')
                            .attr('class', 'link');

                    node = svg.selectAll('.node')
                            .data(nodesList)
                            .enter().append('g')
                            .attr('class', 'node')
                            .on('dblclick', dblclick)
                            .on('click', click)
                            .call(drag);

                    node.append('image')
                            .attr('xlink:href', function(d) {
                                return d.icon;
                            })
                            .attr('x', -settings.iconWidth / 2)
                            .attr('y', -settings.iconHeight / 2)
                            .attr('width', settings.iconWidth)
                            .attr('height', settings.iconHeight);

                    node.append('text')
                            .attr('dx', settings.nodeTextOffsetX)
                            .attr('dy', settings.nodeTextOffsetY)
                            .text(function(d) {
                                return d.name;
                            });

                    console.log('Success');
                }

                /** FUNCTIONALITY **/
                /** Slider control for graph zoom level **/
                function createZoomSlider() {
                    d3.select(css.IDs.zoomSlider).call(
                            d3.slider()
                            .value(settings.baseZoomValue)
                            .on('slide', function(evt, value) {
                                d3.select(css.IDs.zoomValue).text(Math.round(value));
                                resize(value);
                            }));
                }

                function resize(size) {
                    var scaling = size / settings.baseZoomValue;
                    svg.selectAll(css.classes.nodeText).style('font-size', settings.baseFontSize * scaling + 'px');
                    svg.selectAll(css.classes.nodeImage).attr('transform', 'scale(' + scaling + ')');
                    svg.selectAll(css.classes.link).style('stroke-width', scaling);
                }

                /** PRIVATE UTILITY FUNCTIONS **/
                function indexOfName(array, search) {
                    for (var i = 0; i < array.length; ++i) {
                        if (array[i].name === search) {
                            return i;
                        }
                    }

                    return -1;
                }

                function findByName(array, name) {
                    var index = indexOfName(array, name);
                    if (index >= 0) {
                        return array[index];
                    } else {
                        return null;
                    }
                }

                /************************************************************
                 * TypeEnum is created on first call if not already defined.
                 * TypeEnum is a constant static hash such that:
                 * The keys of TypeEnum are fully expanded type names
                 * The values of TypeEnum are corresponding icon paths
                 * 
                 * If TypeEnum holds an icon path for a type it is returned,
                 * otherwise a default icon path is returned.
                 ************************************************************/
                function getIconPath(obj) {
                    if (getIconPath.TypeEnum === undefined) {
                        var types = nodeTypes.typeNames;
                        var icons = nodeTypes.iconNames;
                        getIconPath.TypeEnum = {};

                        for (var i = 0, l = types.length; i < l; ++i) {
                            getIconPath.TypeEnum[types[i]] = settings.baseIconPath + icons[i];
                        }

                        Object.freeze(getIconPath.TypeEnum);
                    }

                    for (var property in obj) {
                        if (property === RDF_PREFIX + 'type') {
                            for (var key in obj[property]) {
                                var type = obj[property][key].value;
                                var path = getIconPath.TypeEnum[type];

                                if (path) {
                                    return path;
                                }
                            }
                        }
                    }

                    return settings.baseIconPath + settings.defaultIcon;
                }

                /** EVENT HANDLER FUNCTIONS **/
                function click(d) {
                    if (d3.event.defaultPrevented) {
                        return; // click suppressed
                    }

                    console.log('Clicked on');
                    console.log(d);

                    var key, node, nodeName;
                    var topology = findByName(topologyList, d.name);
                    for (key in topology.nodes) {
                        nodeName = topology.nodes[key].value;
                        node = findByName(nodesList, nodeName);

                        if (node) {
                            console.log('Toggle ' + nodeName + ' visible:' + !node.visible);
                            node.visible = !node.visible;
                        }
                    }
                    tick();
                }

                function dblclick(d) {
                    d3.select(this).classed('fixed', d.fixed = false);
                }

                function ondrag(d) {
                    d3.select(this).classed('fixed', d.fixed = true);
                }

                /** GRAPH UPDATE **/
                function tick() {
                    link = svg.selectAll('.link');
                    link
                            .attr('x1', function(d) {
                                return d.source.x;
                            })
                            .attr('y1', function(d) {
                                return d.source.y;
                            })
                            .attr('x2', function(d) {
                                return d.target.x;
                            })
                            .attr('y2', function(d) {
                                return d.target.y;
                            });
                    link
                            .attr('opacity', function(d) {
                                if (d.visible) {
                                    return 100;
                                } else {
                                    return 0;
                                }
                            });

                    node = svg.selectAll('.node');
                    node.attr('transform', function(d) {
                        return 'translate(' + d.x + ',' + d.y + ')';
                    });
                    node.attr('opacity', function(d) {
                        if (d.visible) {
                            return 100;
                        } else {
                            return 0;
                        }
                    });
                }

                /** PUBLIC INTERFACE **/
                return {
                    main: main,
                    css: css,
                    settings: settings,
                    types: nodeTypes
                };
            }(); // end adminView module

            adminView.main(); // execute adminView module
        </script>
    </body>
</html>
