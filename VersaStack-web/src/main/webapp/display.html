<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <title>Administrator View</title>
        <meta name="viewport" content="initial-scale=1">
        <link rel="stylesheet" href="css/d3.slider.css" />  

        <style>
            .node {
                cursor: move;
            }

            .node text {
                pointer-events: none;
                font-family: sans-serif;
                font-size: 12px;
            }

            /*.cursor {
                fill: none;
                stroke: brown;
                pointer-events: none;
            }*/

            .link {
                stroke: #999;
                stroke-width: 1.5px;
            }

            .floatTL{
                position: fixed;
                top: 0px;
                left: 0px;
            }
        </style>
    </head>
    <body>
        <div style="width:100%" class="floatTL">
            Scale: <span id="sliderValue">50</span>
            <div id ="slider" style="width:20%"></div>
        </div>


        <script src="http://d3js.org/d3.v3.min.js"></script>
        <script src="js/d3.slider.js"></script>

        <script>
            var BASE_VALUE = 50;
            var BASE_FONT_SIZE = 12;
            // Zoom level slider
            d3.select('#slider').call(
                    d3.slider()
                    .value(BASE_VALUE)
//                    .orientation("vertical")
                    .on("slide", function(evt, value) {
                        d3.select('#sliderValue').text(Math.round(value));
                        resize(value);
                    }));

            function resize(size) {
                var scaling = size / BASE_VALUE;
                svg.selectAll(".node text").style('font-size', BASE_FONT_SIZE * scaling + 'px');
                svg.selectAll(".node image").attr("transform", "scale(" + scaling + ")");
                svg.selectAll(".link").style('stroke-width', scaling);
            }
        </script>

        <script>
            var RDFS_PREFIX = "http://www.w3.org/2000/01/rdf-schema#";
            var RDF_PREFIX = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
            var XSD_PREFIX = "http://www.w3.org/2001/XMLSchema#";
            var OWL_PREFIX = "http://www.w3.org/2002/07/owl#";
            var NML_PREFIX = "http://schemas.ogf.org/nml/2013/03/base#";
            var MRS_PREFIX = "http://schemas.ogf.org/mrs/2013/12/topology#";

            var ICON_PATH = "resources/";

            var width = document.documentElement.clientWidth;
            var height = document.documentElement.clientHeight;
            var canvasWidth = width * 2;
            var canvasHeight = height * 2;

            var nodesList = [];
            var linksList = [];
            var topologyList = [];
            var node = [];
            var link = [];

            var svg = d3.select("body").append("svg")
                    .attr("width", canvasWidth)
                    .attr("height", canvasHeight);

            // Circle around cursor makes it easier to see
//            var cursor = svg.append("circle")
//                    .attr("r", 30)
//                    .attr("class", "cursor");

            d3.json("data/graph-full.json", function(error, json) {
                console.log("Generating node and link lists from json");
                console.log(json);

                for (var obj in json) {
//                    console.log("Processing object:");
//                    console.log(obj);
                    var display = false; //Whether this obj is displayed

                    for (var property in json[obj]) {
                        var done = false;
                        // Do not show labelgroups or addresses
                        // TODO: This code can be refactored by conversion to function
                        if (property.indexOf("labeltype") >= 0) {
                            console.log("Ignored labelgroup " + obj);
                            done = true;
                            display = false;
                            break;
                        } else if (property.indexOf("type") >= 0) {
                            var ignore = false;

                            for (var type in json[obj][property]) {
                                if (json[obj][property][type].value === MRS_PREFIX + "Address") {
                                    console.log("Ignored address " + obj);
                                    ignore = true;
                                    break;
                                } else if (json[obj][property][type].value.indexOf("http://schemas.ogf.org/") >= 0) {
                                    display = true;
                                }
                            }

                            if (ignore) {
                                display = false;
                                done = true;
                                break;
                            }
                        }

                        if (done) {
                            break;
                        }
                    }

                    if (display) { // Add new node
                        var iconPath = (function() { // Find icon based on type
                            for (var property in json[obj]) {
                                if (property === RDF_PREFIX + "type") {
                                    for (var type in json[obj][property]) {
                                        switch (json[obj][property][type].value) {
                                            case NML_PREFIX + "Topology":
                                                return ICON_PATH + "topology.jpg";
                                            case NML_PREFIX + "BidirectionalPort":
                                                return ICON_PATH + "bidirectional_port.jpg";
                                            case MRS_PREFIX + "StorageService":
                                                return ICON_PATH + "storage_service.jpg";
                                            case NML_PREFIX + "Node":
                                                return ICON_PATH + "node.jpg";
                                            case MRS_PREFIX + "BlockStorageService":
                                                return ICON_PATH + "block_storage_service.jpg";
                                            case MRS_PREFIX + "Route":
                                                return ICON_PATH + "route.jpg";
                                            case MRS_PREFIX + "HypervisorBypassInterfaceService":
                                                return ICON_PATH + "hypervisor_bypass_interface_service.jpg";
                                            case NML_PREFIX + "SwitchingService":
                                                return ICON_PATH + "switching_service.jpg";
                                            case MRS_PREFIX + "VirtualSwitchService":
                                                return ICON_PATH + "virtual_switch_service.jpg";
                                            case MRS_PREFIX + "RoutingService":
                                                return ICON_PATH + "routing_service.jpg";
                                            case MRS_PREFIX + "IOPerformanceMeasurementService":
                                                return ICON_PATH + "io_perf_service.jpg";
                                            case MRS_PREFIX + "POSIX_IOBenchmark":
                                                return ICON_PATH + "io_benchmark.jpg";
                                            case MRS_PREFIX + "HypervisorService":
                                                return ICON_PATH + "hypervisor_service.jpg";
                                        }
                                    }
                                }
                            }
                            return ICON_PATH + "default.png";
                        })();
                        var source = {name: obj, icon: iconPath, visible: true};
//                        console.log("Adding object");
//                        console.log(source);
                        nodesList.push(source);
                    }
                }

                for (var obj in json) {
                    // Store topology objects and relations
                    if (obj.indexOf("topology") >= 0) {
                        for (var property in json[obj]) {
                            if (property === NML_PREFIX + "hasNode" || property === NML_PREFIX + "hasService") {
                                var topology = {name: obj, nodes: json[obj][property]};
                                console.log("Adding topology");
                                console.log(topology);
                                topologyList.push(topology);
                                for (var node in json[obj][property]) {
                                    var index = indexOf(nodesList, json[obj][property][node].value);
                                    var sourceIndex = indexOf(nodesList, obj);
                                    if (index >= 0 && sourceIndex >= 0) {
                                        linksList.push({source: nodesList[sourceIndex], target: nodesList[index], visible: false});
                                    }
                                }
                            }
                        }
                    }

                    // Add any alias links that exist
                    for (var property in json[obj]) {
                        if (property.indexOf("isAlias") >= 0) {
//                                console.log("Found links from object");

                            for (var i = 0; i < json[obj][property].length; ++i) {
                                var index = indexOf(nodesList, json[obj][property][i].value);
                                var sourceIndex = indexOf(nodesList, obj);
                                if (index >= 0 && sourceIndex >= 0) {
//                                        console.log("Adding link to");
//                                        console.log(nodesList[index].name);

                                    linksList.push({source: nodesList[sourceIndex], target: nodesList[index], visible: true});
                                }
                            }
                        }
                    }
                }


                // Hide topology nodes by default
                for (var topology in topologyList) {
                    for (var node in topologyList[topology].nodes) {
                        var index = indexOf(nodesList, topologyList[topology].nodes[node].value);
                        if (index >= 0) {
                            nodesList[index].visible = false;
                        }
                    }
                }

                console.log("Initializing force graph");
                /**
                 * k is porportional to the square root of the graph density
                 * and is used as a heuristic to set appropriate values for the
                 * charge and gravity of the force graph
                 * credit to mbostock on Stack Overflow for the idea
                 */
                var k = Math.sqrt(nodesList.length / (canvasWidth * canvasHeight));
                console.log("Calculated k-value " + k); // Heuristic for graph density

                var force = d3.layout.force()
                        .size([canvasWidth, canvasHeight])
                        .charge(-10 / k)
                        .gravity(100 * k)
                        .distance(150)
                        .on("tick", tick)
                        .nodes(nodesList)
                        .links(linksList)
                        .start();

                var drag = force.drag()
                        .on("drag", ondrag)

                link = svg.selectAll(".link")
                        .data(linksList)
                        .enter().append("line")
                        .attr("class", "link")

                node = svg.selectAll(".node")
                        .data(nodesList)
                        .enter().append("g") //or "circle"?
                        .attr("class", "node")
                        .on("dblclick", dblclick)
                        .on("click", click)
                        .call(drag);

                node.append("image")
                        .attr("xlink:href", function(d) {
                            return d.icon;
                        })
                        .attr("x", -20)
                        .attr("y", -15)
                        .attr("width", 30)
                        .attr("height", 30);

                node.append("text")
                        .attr("dx", 12)
                        .attr("dy", ".35em")
                        .text(function(d) {
                            return d.name;
                        });

                console.log("Success");
            });

            function indexOf(array, search) {
                for (var i = 0; i < array.length; ++i) {
                    if (array[i].name === search) {
                        return i;
                    }
                }

                return -1;
            }

//            function linkIndexOf(array, search) {
//                for (var i = 0; i < array.length; ++i) {
//                    if (array[i].source.name === search.source.name
//                            && array[i].target.name === search.target.name) {
//                        return i;
//                    }
//                }
//
//                return -1;
//            }
//
//            function mousemove() {
//                cursor.attr("transform", "translate(" + d3.mouse(this) + ")");
//            }
//
//            function mousedown() {
//                console.log("mousedown");
//            }
//
//            function mouseup() {
//                console.log("mouseup");
//            }

            function click(d) {
                if (d3.event.defaultPrevented) {
                    return; // click suppressed
                }

                console.log("Clicked on");
                console.log(d);
                var index = indexOf(topologyList, d.name);
                if (index >= 0) {
                    for (var node in topologyList[index].nodes) {
                        var nodeIndex = indexOf(nodesList, topologyList[index].nodes[node].value);
                        console.log(topologyList[index].nodes[node].value);
                        console.log(nodeIndex);
                        if (nodeIndex >= 0) {
                            console.log("Toggle " + !nodesList[nodeIndex].visible);
                            nodesList[nodeIndex].visible = !nodesList[nodeIndex].visible;
//                            if (nodesList[nodeIndex].visible) {
//                                d3.select(nodesList[nodeIndex])
//                                        .attr("opacity", 0)
//                                        .transition()
//                                        .ease(Math.sqrt)
//                                        .attr("opacity", 100)
//                            } else {
//                                d3.select(nodesList[nodeIndex])
//                                        .attr("opacity", 100)
//                                        .transition()
//                                        .ease(Math.sqrt)
//                                        .attr("opacity", 0)
//                                        .remove();
//                            }
                        }
                    }
                }
                tick();
            }

//            function svgmousedown() {
//                var point = d3.mouse(this);
//                var n = {x: point[0], y: point[1], name: "hello"};
//                nodesList.push(n);
//
////                 add links to any nearby nodes
//                nodesList.forEach(function(target) {
//                    var x = target.x - n.x,
//                            y = target.y - n.y;
//                    if (Math.sqrt(x * x + y * y) < 30) {
//                        linksList.push({source: n, target: target});
//                    }
//                });
//
//                restart();
//            }

            function dblclick(d) {
                d3.select(this).classed("fixed", d.fixed = false);
            }

//            function dragstart(d) {
//                console.log("dragstart");
//            }

            function ondrag(d) {
//                console.log("drag");
                d3.select(this).classed("fixed", d.fixed = true);
            }

//            function dragend(d) {
//                console.log("dragend");
//            }

            function tick() {
                link = svg.selectAll(".link");
                link
                        .attr("x1", function(d) {
                            return d.source.x;
                        })
                        .attr("y1", function(d) {
                            return d.source.y;
                        })
                        .attr("x2", function(d) {
                            return d.target.x;
                        })
                        .attr("y2", function(d) {
                            return d.target.y;
                        });
                link
                        .attr("opacity", function(d) {
                            if (d.visible) {
                                return 100;
                            } else {
                                return 0;
                            }
                        });

                node = svg.selectAll(".node");
                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
                node.attr("opacity", function(d) {
                    if (d.visible) {
                        return 100;
                    } else {
                        return 0;
                    }
                });
            }

//            function restart() {
//                link = link.data(linksList);
//                link.enter().append("line")
//                        .attr("class", "link");
//
//                node = node.data(nodesList);
//
//                node.enter().append("g") //or "circle"?
//                        .attr("class", "node")
//                        .on("dblclick", dblclick)
//                        .call(drag);
//
//                node.append("image")
//                        .attr("xlink:href", "app.gif")
//                        .attr("x", -8)
//                        .attr("y", -8)
//                        .attr("width", 16)
//                        .attr("height", 16);
//
//                node.append("text")
//                        .attr("dx", 12)
//                        .attr("dy", ".35em")
//                        .text(function(d) {
//                            return d.name;
//                        });
//
//                force.start();
//            }
        </script>
    </body>
</html>